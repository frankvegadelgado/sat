\documentclass[a4paper,UKenglish,cleveref, autoref]{lipics-v2019}
%This is a template for producing LIPIcs articles.
%See lipics-manual.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling cleveref support, use "autoref"
\usepackage{url}

\usepackage[ruled]{algorithm2e} % For algorithms
\renewcommand{\algorithmcfname}{ALGORITHM}
\SetAlFnt{\small}
\SetAlCapFnt{\small}
\SetAlCapNameFnt{\small}
\SetAlCapHSkip{0pt}
\IncMargin{-\parindent}

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Algebraic Polynomial Sum Solver Over $\{0, 1\}$} %TODO Please add

\titlerunning{APSS is in P}%optional, please use if title is longer than one line

\author{Frank Vega}{CopSonic, 1471 Route de Saint-Nauphary 82000 Montauban, France} {vega.frank@gmail.com}{https://orcid.org/0000-0001-8210-4126}{}

\authorrunning{F. Vega}%TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

%\Copyright{John Q. Public and Joan R. Public}%TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/
\ccsdesc[500]{Theory of computation~Complexity classes}
\ccsdesc[300]{Theory of computation~Problems, reductions and completeness}
%%https://dl.acm.org/ccs/ccs_flat.cfm

\keywords{complexity classes, polynomial time, reduction, logarithmic space}%TODO mandatory; please add comma-separated list of keywords

%\category{}%optional, e.g. invited paper

%\relatedversion{}%optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversion{A full version of the paper is available at \url{https://www.academia.edu/39721020/Solution_of_the_P_versus_NP_Problem}.}

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

%\acknowledgements{I want to thank \dots}%optional

\nolinenumbers %uncomment to disable line numbering

\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\EventEditors{John Q. Open and Joan R. Access}
%\EventNoEds{2}
%\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
%\EventShortTitle{CVIT 2016}
%\EventAcronym{CVIT}
%\EventYear{2016}
%\EventDate{December 24-27, 2016}
%\EventLocation{Little Whinging, United Kingdom}
%\EventLogo{}
%\SeriesVolume{42}
%\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
Given a polynomial $P(x_{1}, x_{2}, \ldots, x_{n})$ which is the sum of terms, where each term is a product of two distinct variables, then the problem $APSS$ consists in calculating the total sum value of $\sum_{\forall U_{i}} P(u_{1}, u_{2}, \ldots, u_{n})$, for all the possible assignments $U_{i} = \{u_{1}, u_{2}, ... u_{n}\}$ to the variables such that $u_{j} \in \{0, 1\}$. $APSS$ is the abbreviation for the problem name Algebraic Polynomial Sum Solver Over $\{0, 1\}$. We show that $APSS$ is in $\#L$ and therefore, it is in $FP$ as well. The functional polynomial time solution was implemented with Scala in \url{https://github.com/frankvegadelgado/sat} using the DIMACS format for the formulas in $\textit{MONOTONE-2SAT}$.
\end{abstract}

\section{Introduction}

\subsection{Polynomial time verifiers}

Let $\Sigma$ be a finite alphabet with at least two elements, and let $\Sigma^{*}$ be the set of finite strings over $\Sigma$ \cite{AB09}. A Turing machine $M$ has an associated input alphabet $\Sigma$ \cite{AB09}. For each string $w$ in $\Sigma^{*}$ there is a computation associated with $M$ on input $w$ \cite{AB09}. We say that $M$ accepts $w$ if this computation terminates in the accepting state, that is $M(w)=``yes"$ \cite{AB09}. Note that $M$ fails to accept $w$ either if this computation ends in the rejecting state, that is $M(w)=``no"$, or if the computation fails to terminate, or the computation ends in the halting state with some output, that is $M(w)=y$ (when $M$ outputs the string $y$ on the input $w$) \cite{AB09}.

The language accepted by a Turing machine $M$, denoted $L(M)$, has an associated alphabet $\Sigma$ and is defined by:
\[L(M) = \{w \in \Sigma^{*}: M(w)=``yes" \}.\]
Moreover, $L(M)$ is decided by $M$, when $w \notin L(M)$ if and only if $M(w)=``no"$ \cite{CLRS01}. We denote by $t_{M}(w)$ the number of steps in the computation of $M$ on input $w$ \cite{AB09}. For $n \in \mathbb{N}$ we denote by $T_{M}(n)$ the worst case run time of $M$; that is:
\[T_{M}(n) = max\{t_{M}(w): w \in \Sigma^{n} \}\]
where $\Sigma^{n}$ is the set of all strings over $\Sigma$ of length $n$ \cite{AB09}. We say that $M$ runs in polynomial time if there is a constant $k$ such that for all $n$, $T_{M}(n) \leq n^{k} + k$ \cite{AB09}. In other words, this means the language $L(M)$ can be decided by the Turing machine $M$ in polynomial time. Therefore, $P$ is the complexity class of languages that can be decided by deterministic Turing machines in polynomial time \cite{CLRS01}. A verifier for a language $L_{1}$ is a deterministic Turing machine $M$, where:
\[L_{1} = \{w: M(w, c) = ``yes" \textit{ for some string } c\}.\]
We measure the time of a verifier only in terms of the length of $w$, so a polynomial time verifier runs in polynomial time in the length of $w$ \cite{AB09}. A verifier uses additional information, represented by the symbol $c$, to verify that a string $w$ is a member of $L_{1}$. This information is called certificate. $NP$ is also the complexity class of languages defined by polynomial time verifiers \cite{Pap03}.

A decision problem in $NP$ can be restated in this way: There is a string $c$ with $M(w, c) = ``yes"$ if and only if $w \in L_{1}$, where $L_{1}$ is defined by the polynomial time verifier $M$ \cite{Pap03}. The function problem associated with $L_{1}$, denoted $FL_{1}$, is the following computational problem: Given $w$, find a string $c$ such that $M(w, c) = ``yes"$ if such string exists; if no such string exists, then reject, that is, return $``no"$ \cite{Pap03}. The complexity class of all function problems associated with languages in $NP$ is called $FNP$ \cite{Pap03}. $FP$ is the complexity class that contains those problems in $FNP$ which can be solved in polynomial time \cite{Pap03}.

To attack the $P$ versus $NP$ question the concept of $\textit{NP-completeness}$ has been very useful \cite{GJ79}. A principal $\textit{NP-complete}$ problem is $SAT$ \cite{GJ79}. An instance of $SAT$ is a Boolean formula $\phi$ which is composed of:

\begin{enumerate}
\item Boolean variables: $x_{1}, x_{2},\ldots, x_{n}$;
\item Boolean connectives: Any Boolean function with one or two inputs and one output, such as $\wedge$(AND), $\vee$(OR), $\rightharpoondown$(NOT), $\Rightarrow$(implication), $\Leftrightarrow$(if and only if);
\item and parentheses.
\end{enumerate}

A truth assignment for a Boolean formula $\phi$ is a set of values for the variables in $\phi$. On the one hand, a satisfying truth assignment is a truth assignment that causes $\phi$ to be evaluated as true. On the other hand, a truth assignment that causes $\phi$ to be evaluated as false is a unsatisfying truth assignment. A Boolean formula with some satisfying truth assignment is satisfiable and without any satisfying truth assignment is unsatisfiable. The problem $SAT$ asks whether a given Boolean formula is satisfiable \cite{GJ79}.

An important complexity is $\textit{Sharp-P}$ (denoted as $\#P$) \cite{LV79}. We can also define the class $\#P$ using polynomial time verifiers. Let $\{0, 1\}^{*}$ be the infinite set of binary strings, a function $f : \{0, 1\}^{*} \rightarrow \mathbb{N}$ is in $\#P$ if there exists a polynomial time verifier $M$ such that for every $x \in \{0, 1\}^{*}$,
\[f(x) = |\{y : M(x, y) = ``yes"\}|\]
where $|\cdots|$ denotes the cardinality set function \cite{AB09}. We could use the parsimonious reduction for the completeness of this class \cite{AB09}. In computational complexity theory, a parsimonious reduction is a transformation from one problem to another that preserves the number of solutions \cite{AB09}.

\subsection{Logarithmic space verifiers}

A logarithmic space Turing machine has a read-only input tape, a write-only output tape, and read/write work tapes \cite{MS06}. The work tapes may contain at most $O(\log n)$ symbols \cite{MS06}. In computational complexity theory, $L$ is the complexity class containing those decision problems that can be decided by a deterministic logarithmic space Turing machine \cite{Pap03}. $NL$ is the complexity class containing the decision problems that can be decided by a nondeterministic logarithmic space Turing machine \cite{Pap03}.

We can give a certificate-based definition for $NL$ \cite{AB09}. The certificate-based definition of $NL$ assumes that a logarithmic space Turing machine has another separated read-only tape \cite{AB09}. On each step of the machine, the machine's head on that tape can either stay in place or move to the right \cite{AB09}. In particular, it cannot reread any bit to the left of where the head currently is \cite{AB09}. For that reason, this kind of special tape is called $``$read-once$"$ \cite{AB09}.

A language $L_{1}$ is in $NL$ if there exists a deterministic logarithmic space Turing machine $M$ with an additional special read-once input tape polynomial $p: \mathbb{N} \rightarrow \mathbb{N}$ such that for every $x \in \{0, 1\}^{*}$:
\[x \in L_{1} \Leftrightarrow \exists \ u \in \{0, 1\}^{p([x])} \textit{ such that } M(x, u) = ``yes" \]
where by $M(x, u)$ we denote the computation of $M$ where $x$ is placed on its input tape, and the certificate $u$ is placed on its special read-once tape, and $M$ uses at most $O(\log [x])$ space on its read/write work tapes for every input $x$, where $[\ldots]$ is the bit-length function \cite{AB09}. $M$ is called a logarithmic space verifier \cite{AB09}.

An interesting complexity class is $\textit{Sharp-L}$ (denoted as $\#L$). $\#L$ has the same relation to $L$ as $\#P$ does to $P$ \cite{AJ93}. We can define the class $\#L$ using logarithmic space verifiers as well.

Let $\{0, 1\}^{*}$ be the infinite set of binary strings, a function $f : \{0, 1\}^{*} \rightarrow \mathbb{N}$ is in $\#L$ if there exists a logarithmic space verifier $M$ such that for every $x \in \{0, 1\}^{*}$,
\[f(x) = |\{u : M(x, u) = ``yes"\}|\]
where $|\cdots|$ denotes the cardinality set function \cite{AJ93}. We could use the parsimonious reduction for the completeness of this class too \cite{AB09}.

A logarithmic space transducer is a Turing machine with a read-only input tape, a write-only output tape, and read/write work tapes \cite{MS06}. The work tapes must contain at most $O(\log n)$ symbols \cite{MS06}. A logarithmic space transducer $M$ computes a function $f : \Sigma^{*} \rightarrow \Sigma^{*}$, where $f(w)$ is the string remaining on the output tape after $M$ halts when it is started with $w$ on its input tape \cite{MS06}. We call $f$ a logarithmic space computable function \cite{MS06}. We say that a language $L_{1} \subseteq \{0, 1\}^{*}$ is logarithmic space reducible to a language $L_{2} \subseteq \{0, 1\}^{*}$, written $L_{1} \leq_{l} L_{2}$, if there exists a logarithmic space computable function $f : \{0, 1\}^{*} \rightarrow \{0, 1\}^{*}$ such that for all $x \in \{0, 1\}^{*}$:
\[x \in L_{1} \textit{ if and only if } f(x) \in L_{2}.\]
For example, this kind of reduction is used for the completeness in the $NL$.

A literal in a Boolean formula is an occurrence of a variable or its negation \cite{CLRS01}. A Boolean formula is in conjunctive normal form, or $CNF$, if it is expressed as an AND of clauses, each of which is the OR of one or more literals \cite{CLRS01}. A Boolean formula is in 2-conjunctive normal form or $2CNF$, if each clause has exactly two distinct literals \cite{Pap03}. A relevant $\textit{NL-complete}$ language is $2CNF$ satisfiability, or $2SAT$ \cite{Pap03}. In $2SAT$, it is asked whether a given Boolean formula $\phi$ in $2CNF$ is satisfiable. The instances of $\textit{MONOTONE-2SAT}$ does not contain any negated variable.

\subsection{A polynomial time problem}

Let's define the following problem

\begin{definition}
\label{definition-apss}
$\#\textbf{Algebraic Polynomial Sum Solver Over \{0, 1\}(APSS)}$

INSTANCE: A polynomial $P(x_{1}, x_{2}, \ldots, x_{n})$ which is the sum of terms, where each term is a product of two distinct variables.

ANSWER: Calculate the total sum value of $\sum_{\forall U_{i}} P(u_{1}, u_{2}, \ldots, u_{n})$, for all the possible assignments $U_{i} = \{u_{1}, u_{2}, ... u_{n}\}$ to the variables such that $u_{j} \in \{0, 1\}$.
\end{definition}

Let's see an example:

Instance: $P(x_{1}, x_{2}, x_{3}) = x_{1} \times x_{2} + x_{2} \times x_{3}$.

Answer: The total sum value is 4 for all the possible assignments:

\begin{table}[]
\caption{Evaluation for all possible assignments}
\label{tab:my-table}
\begin{tabular}{|l|l|l|c|}
$x_{1}$ & $x_{2}$ & $x_{3}$ & $P(x_{1}, x_{2}, x_{3})$ \\
\hline                                                 
1       & 1       & 1       & 2                        \\
1       & 1       & 0       & 1                        \\
0       & 1       & 1       & 1                        \\
0       & 0       & 0       & 0                        \\
1       & 0       & 1       & 0                        \\
0       & 0       & 1       & 0                        \\
1       & 0       & 0       & 0                        \\
0       & 1       & 0       & 0
\end{tabular}
\end{table}

$\textbf{Total}: 2 + 1 + 1 + 0 + 0 + 0 + 0 + 0 = \textbf{4}$ (see it in Table \ref{tab:my-table}).

We solve this problem reducing in logarithmic space and parsimoniously to another problem $\#\textit{CLAUSES-2UNSAT}$. We show an algorithm for the problem $\#\textit{CLAUSES-2UNSAT}$ which is in $\#L$ and therefore, it is in $FP$ as well. In this way, we prove that $APSS$ can be solved in polynomial time.

\section{Results}

\begin{definition}
Given a Boolean formula $\phi$ with $m$ clauses, the density of states $n(E)$ for some integer $0 \leq E \leq m$ counts the number of truth assignments that leave exactly $E$ clauses unsatisfied in $\phi$ \cite{SCB10}. The weighted density of states $m(E)$ is equal to $E \times n(E)$. The sum of the weighted densities of states of a Boolean formula in $2CNF$ with $m$ clauses is equal to $\sum_{E = 0}^{m} m(E)$.
\end{definition}

Let's consider a function problem:

\begin{definition}
\label{monotone}
$\#\textbf{CLAUSES-2UNSAT}$

INSTANCE: Two natural numbers $n$, $m$, and a Boolean formula $\phi$ in $2CNF$ of $n$ variables and $m$ clauses. The clauses are represented by an array $C$, such that $C$ represents a set of $m$ set elements, where $C[i] = S_{i}$ if and only if $S_{i}$ is exactly the set of literals into a clause $c_{i}$ in $\phi$ for $1 \leq i \leq m$. Besides, each variable in $\phi$ is represented by a unique integer between $1$ and $n$. In addition, a negative or positive integer represents a negated or non-negated literal, respectively. This is similar to the format [DIMACS](\url{http://www.satcompetition.org/2009/format-benchmarks2009.html}) for the formulas where the literals are represented by negative or nonnegative integers.

ANSWER: The sum of the weighted densities of states of the Boolean formula $\phi$.
\end{definition}

\begin{algorithm}
\caption{$\textit{ALGO}$}\label{algorithm}
\KwData{$(n, m, C)$  where $(n, m, C)$ is an instance of $\#\textit{CLAUSES-2UNSAT}$}
\KwResult{Accept whether there is an unsatisfied clause for a generated truth assignment}
\BlankLine
\tcp{Generate nondeterministically an arbitrary integer between $1$ and $m$}
$k \longleftarrow \textit{random}(1, m)$\;
\tcp{Initialize the variable $count$}
$count \longleftarrow 0$\;

\For{$i\gets1$ \KwTo $n + 1$}{
\If{$i = n + 1$}{
\If{$count = 2$}{
    \tcp{The clause $C[k]$ is unsatisfied for the generated truth assignment}
    \KwRet{$``yes"$}\;
    }
\Else{
    \tcp{The clause $C[k]$ is satisfied for the generated truth assignment}
    \KwRet{$``no"$}\;
    }
    
}
\Else{
\tcp{Generate nondeterministically either the integer $i$ or $-i$}
$y \longleftarrow \textit{random}(i)$\;
\For{$j\gets 1$ \KwTo $m$}{
\If{$y \in C[j] \wedge j = k$}{
\tcp{Increment the value of the variable $count$}
$count \longleftarrow count + 1$\;
}
}
}
}
\end{algorithm}

\begin{theorem}
\label{myproof}
$\#\textit{CLAUSES-2UNSAT} \in \#L$.
\end{theorem}

\begin{proof}
We are going to show there is a nondeterministic Turing machine $M$ such that $M$ runs in logarithmic space in the length of $(n, m, C)$. We use the nondeterministic logarithmic space Algorithm \ref{algorithm}, where this routine generates a truth assignment in logarithmic space just selecting a negation or a positive representation of a variable $1 \leq i \leq n$, since every variable is represented by an integer between $1$ and $n$ in $C$. We also assume the value of each literal selected within $y$ is false over the generated truth assignment.

First of all, the Algorithm \ref{algorithm} select the index in $C$ of a clause from the value of the variable $k$. Later, we increment the variable $count$ as much as the literal $y$ appears in the clause $C[k]$. Since a clause contains only two literals, then if we finish the iteration of the possible values in the generated truth assignment, then we can say the clause indexed with the number $k$ in $C$ is unsatisfied when $count = 2$.

Furthermore, we can make this Algorithm \ref{algorithm} in logarithmic space, because the variables that we could use for the iteration of the variables and elements in $C$ have a logarithmic space in relation to the length of the instance $(n, m, C)$. Besides, the Algorithm \ref{algorithm} is nondeterministic, since we generate in a nondeterministic way the values of the variables $k$ and $y$. In addition, every generated truth assignment is always stored in logarithmic space in relation to the instance $(n, m, C)$, since we only focus in a single literal of the truth assignment from the for loop each time.

For every unsatisfying truth assignment represented by a generated truth assignment, then there will be always as many acceptance paths as unsatisfied clauses have the evaluation of that truth assignment in the formula $\phi$. Consequently, we demonstrate that $\#\textit{CLAUSES-2UNSAT}$ belongs to the complexity class $\#L$. Certainly, the number of all accepting paths in the Algorithm \ref{algorithm} is exactly the sum of the number of unsatisfied clauses from all the truth assignments in $\phi$, that is exactly the sum of the weighted densities of states of the Boolean formula $\phi$. In conclusion, we show that $\#\textit{CLAUSES-2UNSAT}$ is indeed in $\#L$.
\end{proof}

Let's consider an interesting reduction:

\begin{theorem}
\label{reduction}
$APSS \leq_{l} \#\textit{CLAUSES-2UNSAT}$, where this logarithm space reduction is a parsimonious reduction.
\end{theorem}

\begin{proof}
We solve this problem reducing in logarithmic space the polynomial $P(x_{1}, x_{2}, \ldots, x_{n})$ into a $\textit{MONOTONE-2SAT}$ formula $\phi$ such that for each term $x_{i} \times x_{j}$, we make a clause $(x_{i} \vee x_{j})$ and join all the summands by a disjunction with the $\wedge$(AND) operator. Let's take as example the previous instance $P(x_{1}, x_{2}, x_{3}) = x_{1} \times x_{2} + x_{2} \times x_{3}$ of $APSS$ which could be reduced to $\phi = (x_{1} \vee x_{2}) \wedge (x_{2} \vee x_{3})$ (the sum of the weighted densities of states for the Boolean formula $\phi$ is $4$). This is equivalent to

p cnf 3 2

1 2 0

2 3 0 

in the format DIMACS. Certainly, we can affirm the value of a term $x_{i} \times x_{j}$ is equal to $1$ when $(x_{i} \vee x_{j})$ is unsatisfied. Consequently, the sum of the weighted densities of states of the Boolean formula $\phi$ will be equal to the answer of the instance for $APSS$, that is a parsimonious reduction. Indeed, every unsatisfying truth assignment $T_{i} = \{t_{1}, t_{2}, ... t_{n}\}$ in $\phi$ with $K$ unsatisfied clauses corresponds to an assignment $U_{i} = \{u_{1}, u_{2}, ... u_{n}\}$ such that $P(u_{1}, u_{2}, \ldots, u_{n}) = K$, where for each $j$ we have $``u_{j} = \rightharpoondown t_{j}"$ (which actually means $u_{j} = 1$ if and only if $t_{j}$ is false).
\end{proof}

\begin{theorem}
\label{final}
$APSS \in \#L$ and therefore, $APSS \in FP$.
\end{theorem}

\begin{proof}
We know $\#L$ is closed under a logarithm space reduction when this one is also a parsimonious reduction. Furthermore, we know that $\#L$ is contained in the class $FP$ \cite{AJ93}, \cite{BCP83}, \cite{AB09}.
\end{proof}

\subsection{Code}

This project was implemented on February 8th of 2021 in a GitHub Repository \cite{FV21}. This was a partial implementation since this project receives as input the already reduced $\textit{MONOTONE-2SAT}$ formulas in the format DIMACS instead of instances from $APSS$.

\bibliography{manuscript}

\end{document} 